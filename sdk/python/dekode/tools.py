"""LLM tool descriptors and dispatch for the Dekode Agent Protocol.

Provides :func:`dekode_tools` to generate Claude-compatible tool definitions
with ``allowed_callers`` for programmatic tool calling, and
:func:`dispatch_tool` to execute tool calls against a
:class:`~dekode.session.DekodeSession`.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import TYPE_CHECKING

from dekode.models import Change, ChangeType, ContextDepth

if TYPE_CHECKING:
    from dekode.session import DekodeSession

_MANIFEST_PATH = Path(__file__).parent / "dkod-tools.json"


def dekode_tools() -> list[dict]:
    """Return all dkod tool definitions for Anthropic's ``tools=`` parameter.

    Loads the tool manifest generated by the Rust SDK. Each tool includes
    ``allowed_callers: ["code_execution_20260120"]`` for programmatic calling.

    Returns
    -------
    list[dict]
        Six tool definitions ready to be passed directly to the Anthropic API.
    """
    return json.loads(_MANIFEST_PATH.read_text())


# Legacy aliases for backward compatibility
_LEGACY_ALIASES = {
    "search_codebase": "dkod_context",
    "submit_changes": "dkod_submit",
}


def dispatch_tool(session: DekodeSession, name: str, input: dict) -> str:
    """Execute a tool call against *session* and return JSON.

    Parameters
    ----------
    session:
        An active :class:`~dekode.session.DekodeSession`.
    name:
        The tool name (e.g. ``"dkod_context"``, ``"dkod_submit"``).
        Legacy names ``"search_codebase"`` and ``"submit_changes"`` are
        accepted as aliases.
    input:
        The tool input dict (matching the corresponding ``input_schema``).

    Returns
    -------
    str
        JSON-serialised result.

    Raises
    ------
    ValueError
        If *name* is not a recognised tool.
    """
    # Resolve legacy aliases
    name = _LEGACY_ALIASES.get(name, name)

    if name == "dkod_context":
        result = session.context(
            query=input["query"],
            depth=ContextDepth(input.get("depth", "FULL").upper()),
            max_tokens=input.get("max_tokens", 8000),
        )
        return result.model_dump_json()

    if name == "dkod_submit":
        changes = [
            Change(
                type=ChangeType(c["type"]),
                symbol_name=c["symbol_name"],
                file_path=c["file_path"],
                new_source=c["new_source"],
                rationale=c["rationale"],
            )
            for c in input.get("changes", [])
        ]
        result = session.submit(changes, input["intent"])
        return result.model_dump_json()

    if name == "dkod_read_file":
        result = session.file_read(input["path"])
        return json.dumps(result)

    if name == "dkod_write_file":
        result = session.file_write(input["path"], input["content"])
        return json.dumps(result)

    if name == "dkod_session_status":
        result = session.session_status()
        return json.dumps(result)

    if name == "dkod_connect":
        # Connect is typically handled before the session exists.
        # This is a no-op if the session is already connected.
        return json.dumps({
            "session_id": session.session_id,
            "status": "already_connected",
        })

    raise ValueError(f"Unknown tool: {name}")
